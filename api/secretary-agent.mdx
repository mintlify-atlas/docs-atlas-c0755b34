---
title: 'Secretary Agent API'
description: 'Complete API reference for the Secretary agent pattern with human-in-the-loop workflows'
icon: 'user-tie'
---

## Overview

The Secretary Agent implements a human-in-the-loop workflow pattern with five phases: receiving ideas, clarifying requirements, dispatching tasks, monitoring execution, and generating reports. It provides an extensible framework for intelligent assistants with customizable behaviors.

## Architecture

```text
┌─────────────────────────────────────────────────────────┐
│              Secretary Agent Workflow                   │
├─────────────────────────────────────────────────────────┤
│  1. Receive Ideas     → Record todos                    │
│  2. Clarify Requirements → Project documents            │
│  3. Dispatch & Schedule → Call execution agents         │
│  4. Monitor Feedback  → Push key decisions to humans    │
│  5. Generate Report   → Update todos, deliverables      │
└─────────────────────────────────────────────────────────┘
```

## Core Engine

### SecretaryCore

Lightweight event loop engine that manages the secretary lifecycle.

```rust
pub struct SecretaryCore<B: SecretaryBehavior> {
    behavior: B,
    config: SecretaryCoreConfig,
}
```

<ResponseField name="start" type="async fn">
  Starts the secretary as an async task
  
  ```rust
  pub async fn start<C>(
      self,
      connection: C,
  ) -> (SecretaryHandle, JoinHandle<GlobalResult<()>>)
  where
      C: UserConnection<Input = B::Input, Output = B::Output> + 'static
  ```
  
  **Returns:**
  - `SecretaryHandle`: Control handle for managing the secretary
  - `JoinHandle`: Task handle for the event loop
</ResponseField>

<ResponseField name="run" type="async fn">
  Runs the secretary synchronously (blocking)
  
  ```rust
  pub async fn run<C>(self, connection: C) -> GlobalResult<()>
  where
      C: UserConnection<Input = B::Input, Output = B::Output> + 'static
  ```
</ResponseField>

### SecretaryCoreBuilder

Builder for configuring secretary core behavior.

```rust
let core = SecretaryCoreBuilder::new(behavior)
    .with_poll_interval(100)
    .with_welcome(true)
    .with_periodic_check(true)
    .with_periodic_check_interval(1000)
    .with_max_consecutive_errors(10)
    .build();
```

<ParamField path="with_poll_interval" type="u64" default="100">
  Event loop polling interval in milliseconds
</ParamField>

<ParamField path="with_welcome" type="bool" default="true">
  Send welcome message on startup
</ParamField>

<ParamField path="with_periodic_check" type="bool" default="true">
  Enable periodic background checks
</ParamField>

<ParamField path="with_periodic_check_interval" type="u64" default="1000">
  Interval for periodic checks in milliseconds
</ParamField>

<ParamField path="with_max_consecutive_errors" type="u32" default="10">
  Maximum consecutive errors before stopping
</ParamField>

### SecretaryHandle

Control handle for managing secretary state.

```rust
// Check status
if handle.is_running() {
    println!("Secretary is active");
}

// Pause/Resume
handle.pause();
handle.resume();

// Stop
handle.stop().await;
```

<ResponseField name="is_running" type="fn() -> bool">
  Check if secretary is running
</ResponseField>

<ResponseField name="is_paused" type="fn() -> bool">
  Check if secretary is paused
</ResponseField>

<ResponseField name="pause" type="fn()">
  Pause the secretary (stops processing input)
</ResponseField>

<ResponseField name="resume" type="fn()">
  Resume the secretary
</ResponseField>

<ResponseField name="stop" type="async fn()">
  Stop the secretary gracefully
</ResponseField>

## Behavior Trait

### SecretaryBehavior

Core trait defining secretary behavior (from `mofa-kernel`).

```rust
#[async_trait]
pub trait SecretaryBehavior: Send + Sync {
    type Input: SecretaryInput;
    type Output: SecretaryOutput;
    type State: Send + Sync;

    async fn handle_input(
        &self,
        input: Self::Input,
        ctx: &mut SecretaryContext<Self::State>,
    ) -> GlobalResult<Vec<Self::Output>>;

    fn initial_state(&self) -> Self::State;
    
    fn welcome_message(&self) -> Option<Self::Output> { None }
    
    async fn periodic_check(
        &self,
        ctx: &mut SecretaryContext<Self::State>,
    ) -> GlobalResult<Vec<Self::Output>> { Ok(vec![]) }
    
    fn handle_error(&self, error: &GlobalError) -> Option<Self::Output> { None }
    
    async fn on_disconnect(
        &self,
        ctx: &mut SecretaryContext<Self::State>,
    ) -> GlobalResult<()> { Ok(()) }
}
```

<ParamField path="Input" type="type" required>
  Input message type (must implement `SecretaryInput`)
</ParamField>

<ParamField path="Output" type="type" required>
  Output message type (must implement `SecretaryOutput`)
</ParamField>

<ParamField path="State" type="type" required>
  Internal state type (must be `Send + Sync`)
</ParamField>

<ParamField path="handle_input" type="async fn" required>
  Process user input and return outputs
</ParamField>

<ParamField path="initial_state" type="fn" required>
  Create initial state
</ParamField>

<ParamField path="welcome_message" type="fn">
  Optional welcome message sent on startup
</ParamField>

<ParamField path="periodic_check" type="async fn">
  Background task executed periodically
</ParamField>

<ParamField path="handle_error" type="fn">
  Convert errors to user-facing output
</ParamField>

<ParamField path="on_disconnect" type="async fn">
  Cleanup on connection close
</ParamField>

## Default Implementation

### DefaultSecretaryBehavior

Complete secretary implementation with todo management, clarification, dispatch, and monitoring.

```rust
let behavior = DefaultSecretaryBuilder::new()
    .with_name("Project Secretary")
    .with_dispatch_strategy(DispatchStrategy::CapabilityFirst)
    .with_auto_clarify(true)
    .with_auto_dispatch(true)
    .with_llm(llm_provider)
    .with_executor(frontend_agent)
    .with_executor(backend_agent)
    .build();
```

### DefaultSecretaryBuilder

Builder for default secretary behavior.

<ParamField path="with_name" type="String">
  Secretary display name
</ParamField>

<ParamField path="with_dispatch_strategy" type="DispatchStrategy">
  Strategy for assigning tasks:
  - `CapabilityFirst`: Match by agent capabilities
  - `LoadBalancing`: Distribute evenly
  - `RoundRobin`: Rotate assignments
  - `Random`: Random selection
</ParamField>

<ParamField path="with_auto_clarify" type="bool" default="false">
  Automatically clarify ambiguous requirements
</ParamField>

<ParamField path="with_auto_dispatch" type="bool" default="false">
  Automatically dispatch to execution agents
</ParamField>

<ParamField path="with_llm" type="Arc<dyn LLMProvider>">
  LLM provider for intelligent processing
</ParamField>

<ParamField path="with_executor" type="AgentInfo">
  Register an execution agent
</ParamField>

## Input/Output Types

### DefaultInput

Standard input messages for secretary.

<ResponseField name="Idea">
  User submits an idea or request
  
  ```rust
  DefaultInput::Idea {
      content: String,
      priority: Option<TodoPriority>,
      metadata: Option<HashMap<String, String>>,
  }
  ```
</ResponseField>

<ResponseField name="Query">
  Query secretary status or information
  
  ```rust
  DefaultInput::Query {
      query_type: QueryType,
      parameters: Option<HashMap<String, String>>,
  }
  ```
</ResponseField>

<ResponseField name="Command">
  Execute secretary command
  
  ```rust
  DefaultInput::Command {
      command: SecretaryCommand,
      args: Vec<String>,
  }
  ```
</ResponseField>

<ResponseField name="Response">
  Human response to secretary question
  
  ```rust
  DefaultInput::Response {
      response: HumanResponse,
  }
  ```
</ResponseField>

### DefaultOutput

Standard output messages from secretary.

<ResponseField name="Message">
  General message to user
  
  ```rust
  DefaultOutput::Message { content: String }
  ```
</ResponseField>

<ResponseField name="Acknowledgment">
  Confirm receipt and processing
  
  ```rust
  DefaultOutput::Acknowledgment { message: String }
  ```
</ResponseField>

<ResponseField name="DecisionRequired">
  Request human decision
  
  ```rust
  DefaultOutput::DecisionRequired {
      decision: CriticalDecision,
  }
  ```
</ResponseField>

<ResponseField name="Report">
  Status or completion report
  
  ```rust
  DefaultOutput::Report { report: Report }
  ```
</ResponseField>

<ResponseField name="Error">
  Error notification
  
  ```rust
  DefaultOutput::Error { message: String }
  ```
</ResponseField>

## Components

### TodoManager

Manages todo items with priorities and status tracking.

```rust
let mut manager = TodoManager::new();

// Add todo
let id = manager.add_todo(
    "Implement feature",
    Some(TodoPriority::High),
    None,
)?;

// Update status
manager.update_status(&id, TodoStatus::InProgress)?;

// Query
let pending = manager.get_by_status(TodoStatus::Pending);
let high_priority = manager.get_by_priority(TodoPriority::High);
```

<ResponseField name="add_todo" type="fn">
  Add new todo item
  
  ```rust
  pub fn add_todo(
      &mut self,
      content: impl Into<String>,
      priority: Option<TodoPriority>,
      metadata: Option<HashMap<String, String>>,
  ) -> GlobalResult<String>
  ```
</ResponseField>

<ResponseField name="update_status" type="fn">
  Update todo status
  
  ```rust
  pub fn update_status(
      &mut self,
      id: &str,
      status: TodoStatus,
  ) -> GlobalResult<()>
  ```
</ResponseField>

<ResponseField name="get_by_status" type="fn">
  Query todos by status
  
  ```rust
  pub fn get_by_status(&self, status: TodoStatus) -> Vec<&TodoItem>
  ```
</ResponseField>

### RequirementClarifier

Clarifies ambiguous requirements through LLM analysis.

```rust
let clarifier = RequirementClarifier::new(llm_provider);

let questions = clarifier.clarify_requirement(
    "Build a web app",
    ClarificationStrategy::Interactive,
).await?;
```

<ParamField path="strategy" type="ClarificationStrategy">
  Clarification approach:
  - `Interactive`: Ask user questions
  - `Automatic`: LLM infers requirements
  - `Hybrid`: Combine both approaches
</ParamField>

### TaskCoordinator

Coordinates task dispatch to execution agents.

```rust
let coordinator = TaskCoordinator::new(
    agent_router,
    DispatchStrategy::CapabilityFirst,
);

let result = coordinator.dispatch_task(
    "Implement UI",
    vec!["frontend", "ui_design"],
).await?;
```

<ResponseField name="dispatch_task" type="async fn">
  Dispatch task to appropriate agent
  
  ```rust
  pub async fn dispatch_task(
      &self,
      task: &str,
      required_capabilities: Vec<&str>,
  ) -> GlobalResult<DispatchResult>
  ```
</ResponseField>

### TaskMonitor

Monitors task execution with rule-based alerts.

```rust
let monitor = TaskMonitor::new();

// Add monitoring rule
monitor.add_rule(MonitoringRule {
    name: "timeout_alert",
    condition: |snapshot| snapshot.elapsed_ms > 60000,
    action: |snapshot| {
        // Send alert
    },
});

// Update task
monitor.update_task(&task_id, snapshot).await?;
```

### Reporter

Generates reports in various formats.

```rust
let reporter = Reporter::new();

let report = reporter.generate(
    ReportType::Progress,
    ReportConfig {
        format: ReportFormat::Markdown,
        include_details: true,
        include_timeline: true,
    },
).await?;
```

## Connection Types

### ChannelConnection

In-memory channel-based connection.

```rust
let (connection, input_tx, output_rx) = ChannelConnection::new_pair(32);

// Send input
input_tx.send(DefaultInput::Idea {
    content: "New feature".to_string(),
    priority: None,
    metadata: None,
}).await?;

// Receive output
while let Some(output) = output_rx.recv().await {
    match output {
        DefaultOutput::Message { content } => {
            println!("Secretary: {}", content);
        }
        _ => {}
    }
}
```

### TimeoutConnection

Wrapper adding timeout behavior to connections.

```rust
let connection = TimeoutConnection::new(
    base_connection,
    Duration::from_secs(30),
);
```

## Agent Routing

### AgentRouter

Routes tasks to appropriate execution agents.

```rust
let router = AgentRouter::new(agent_provider)
    .with_capability_matching(true)
    .with_load_balancing(true);

let agent = router.route(
    &task,
    &["frontend", "react"],
).await?;
```

### AgentInfo

Metadata about execution agents.

```rust
let mut agent = AgentInfo::new("frontend_agent", "Frontend Development Agent");
agent.capabilities = vec!["frontend", "ui_design", "react"];
agent.current_load = 20;
agent.available = true;
agent.performance_score = 0.85;
```

<ParamField path="id" type="String" required>
  Unique agent identifier
</ParamField>

<ParamField path="name" type="String" required>
  Human-readable name
</ParamField>

<ParamField path="capabilities" type="Vec<String>">
  Agent capabilities/skills
</ParamField>

<ParamField path="current_load" type="u32">
  Current workload (0-100)
</ParamField>

<ParamField path="available" type="bool">
  Whether agent is available
</ParamField>

<ParamField path="performance_score" type="f32">
  Performance rating (0.0-1.0)
</ParamField>

## LLM Integration

### LLMProvider Trait

Trait for LLM integration in secretary.

```rust
#[async_trait]
pub trait LLMProvider: Send + Sync {
    fn name(&self) -> &str;
    async fn chat(&self, messages: &[ChatMessage]) -> GlobalResult<String>;
    async fn analyze(&self, prompt: &str) -> GlobalResult<serde_json::Value>;
}
```

### ChatMessage

Conversation message for LLM.

```rust
let messages = vec![
    ChatMessage::system("You are a helpful assistant"),
    ChatMessage::user("Clarify this requirement: Build a web app"),
];

let response = llm_provider.chat(&messages).await?;
```

## Work Phases

### WorkPhase

Secretary workflow phases.

<ResponseField name="Receiving">
  Receiving and recording ideas
</ResponseField>

<ResponseField name="Clarifying">
  Clarifying requirements
</ResponseField>

<ResponseField name="Dispatching">
  Dispatching to execution agents
</ResponseField>

<ResponseField name="Monitoring">
  Monitoring task progress
</ResponseField>

<ResponseField name="Reporting">
  Generating reports
</ResponseField>

## Complete Example

```rust
use mofa_foundation::secretary::*;
use mofa_foundation::llm::*;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Create LLM provider
    let llm_provider = create_openai_provider(api_key);
    
    // Define execution agents
    let mut frontend_agent = AgentInfo::new(
        "frontend_agent",
        "Frontend Developer"
    );
    frontend_agent.capabilities = vec!["frontend", "react", "ui"];
    
    let mut backend_agent = AgentInfo::new(
        "backend_agent",
        "Backend Developer"
    );
    backend_agent.capabilities = vec!["backend", "api", "database"];
    
    // Build secretary
    let secretary = DefaultSecretaryBuilder::new()
        .with_name("Development Secretary")
        .with_dispatch_strategy(DispatchStrategy::CapabilityFirst)
        .with_auto_clarify(true)
        .with_auto_dispatch(true)
        .with_llm(llm_provider)
        .with_executor(frontend_agent)
        .with_executor(backend_agent)
        .build();
    
    // Create connection
    let (connection, input_tx, mut output_rx) = 
        ChannelConnection::new_pair(32);
    
    // Start secretary
    let (handle, join_handle) = SecretaryCore::new(secretary)
        .start(connection)
        .await;
    
    // Send idea
    input_tx.send(DefaultInput::Idea {
        content: "Build a user management system".to_string(),
        priority: Some(TodoPriority::High),
        metadata: None,
    }).await?;
    
    // Receive responses
    while let Some(output) = output_rx.recv().await {
        match output {
            DefaultOutput::Message { content } => {
                println!("Secretary: {}", content);
            }
            DefaultOutput::DecisionRequired { decision } => {
                println!("Decision needed: {}", decision.description);
                // Send human response
            }
            DefaultOutput::Report { report } => {
                println!("Report:\n{}", report.content);
            }
            _ => {}
        }
    }
    
    // Stop secretary
    handle.stop().await;
    join_handle.await??;
    
    Ok(())
}
```

## Source Reference

- Core engine: `~/workspace/source/crates/mofa-foundation/src/secretary/core.rs`
- Module exports: `~/workspace/source/crates/mofa-foundation/src/secretary/mod.rs`
- Default implementation: `~/workspace/source/crates/mofa-foundation/src/secretary/default/`
- Example: `~/workspace/source/examples/secretary_agent/src/main.rs`